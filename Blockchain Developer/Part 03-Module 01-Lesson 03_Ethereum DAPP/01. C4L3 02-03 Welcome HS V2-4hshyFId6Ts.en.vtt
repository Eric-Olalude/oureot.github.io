WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.580
Welcome to our lesson on creating DApps.

00:00:02.580 --> 00:00:05.925
A DApp stands for a decentralized application.

00:00:05.924 --> 00:00:09.179
Designing a DApp starts with writing a smart contract,

00:00:09.179 --> 00:00:11.519
deploying it to an Ethereum network,

00:00:11.519 --> 00:00:15.570
followed by designing a front-end to interact with the smart contract.

00:00:15.570 --> 00:00:18.885
Now, that means being able to call functions,

00:00:18.885 --> 00:00:20.925
make transactions, et cetera.

00:00:20.925 --> 00:00:25.410
In this lesson, we will write a smart contract to notarize a star.

00:00:25.410 --> 00:00:26.894
A question you might have,

00:00:26.894 --> 00:00:28.859
why did we choose this project?

00:00:28.859 --> 00:00:33.799
Notarizing a star means to own a star if it is not owned by anyone yet.

00:00:33.799 --> 00:00:35.390
Once you own a star,

00:00:35.390 --> 00:00:37.460
you can sell it to anyone else.

00:00:37.460 --> 00:00:39.905
You can also buy stars from someone else.

00:00:39.905 --> 00:00:43.189
This will really help you understand how Ethereum can help

00:00:43.189 --> 00:00:46.939
us make transactions without any third party involvement.

00:00:46.939 --> 00:00:48.754
Let me explain this further.

00:00:48.755 --> 00:00:52.175
We will write two versions of the smart contract,

00:00:52.174 --> 00:00:54.439
version one and version two.

00:00:54.439 --> 00:00:56.479
We will keep version one simple.

00:00:56.479 --> 00:00:58.024
We will create a star,

00:00:58.024 --> 00:01:00.289
claim a star in this contract,

00:01:00.289 --> 00:01:02.825
and then we will also learn how to write

00:01:02.825 --> 00:01:07.685
test cases to test the smart contract using Mocha, Chai, and Truffle.

00:01:07.685 --> 00:01:12.995
We will then create a front-end for this DApp using basic JavaScript and HTML.

00:01:12.995 --> 00:01:14.859
Using this front-end web page,

00:01:14.859 --> 00:01:17.030
we will call functions on a contract.

00:01:17.030 --> 00:01:20.585
Now, this will finish the first part of our lesson.

00:01:20.584 --> 00:01:22.459
After writing version one,

00:01:22.459 --> 00:01:26.404
we will then write our version two of the star node tree smart contract.

00:01:26.405 --> 00:01:29.150
We will add functions to create a star,

00:01:29.150 --> 00:01:30.484
put up stars for sale,

00:01:30.484 --> 00:01:32.269
buy a star, and even more.

00:01:32.269 --> 00:01:34.854
We will then tokenize our stars.

00:01:34.855 --> 00:01:40.980
To do this, we will adopt the ERC-721 standard and make our star tokens non-fungible.

00:01:40.980 --> 00:01:45.409
Remember, we learned about ERC-20 fungible tokens in a previous lesson.

00:01:45.409 --> 00:01:51.164
In this lesson, we will now learn about the ERC-721 non-fungible standard,

00:01:51.165 --> 00:01:55.460
and then write version two of the Star Notary smart contract by

00:01:55.459 --> 00:02:00.054
using OpenZeppelin to encode the ERC-721 interface.

00:02:00.055 --> 00:02:02.190
Once a smart contract is written,

00:02:02.189 --> 00:02:05.909
we will then write test cases in Truffle using Mocha and

00:02:05.909 --> 00:02:10.025
Chai to make sure a contract works the way it is intended to work.

00:02:10.025 --> 00:02:15.275
We will then design a front-end of the Star Notary smart contract version two.

00:02:15.275 --> 00:02:18.349
I will show you how to create a basic front page while

00:02:18.349 --> 00:02:22.859
the other options will be left for you to complete as a part of project five.

00:02:22.860 --> 00:02:24.960
So, let's get started.
最新课程跟课件还有一对一辅导请加wx：udacity6
